"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var KJUR = tslib_1.__importStar(require("jsrsasign"));
var api_1 = tslib_1.__importDefault(require("./api"));
var Utils_1 = tslib_1.__importDefault(require("./utils/Utils"));
var Security = /** @class */ (function () {
    function Security() {
    }
    Security.getConfig = function (clientId) {
        return {
            'clientId': clientId || Utils_1.default.env.VUE_APP_CLIENT_ID,
            'realm': Utils_1.default.env.VUE_APP_REALM,
            'realm-public-key': Utils_1.default.env.VUE_APP_REALM_PUBLIC_KEY,
            'url': Utils_1.default.urls.login,
            'auth-server-url': Utils_1.default.urls.login,
            'ssl-required': Utils_1.default.env.VUE_APP_SSL_REQUIRED,
            'resource': clientId,
            'public-client': Utils_1.default.env.VUE_APP_PUBLIC_CLIENT,
        };
    };
    Security.login = function (clientId) {
        return Security.initializeAuth(Security.getConfig(clientId), 'login-required');
    };
    Security.checkAuthenticated = function (clientId) {
        return Security.initializeAuth(Security.getConfig(clientId), 'check-sso');
    };
    Security.verifyAndLogin = function (rawBearerToken, useTokenToLogin, showLoginScreen, redirectUrl) {
        var token = Security.parseToken(rawBearerToken);
        if (Security.verifyToken(rawBearerToken, token)) {
            var clientId = Security.resolveClientId(token, useTokenToLogin);
            var config = Security.getConfig(clientId);
            return Security.initializeAuth(config, showLoginScreen ? 'login-required' : 'check-sso', redirectUrl);
        }
        else {
            Security.notAuthenticated();
            return Promise.resolve({ keycloak: {}, authenticated: false });
        }
    };
    Security.parseToken = function (rawBearerToken) {
        try {
            var jws = new KJUR.jws.JWS();
            jws.parseJWS(rawBearerToken);
            return JSON.parse(jws.parsedJWS.payloadS);
        }
        catch (e) {
            return null;
        }
    };
    Security.verifyToken = function (rawBearerToken, parsedToken) {
        try {
            var publicKey = Utils_1.default.env.VUE_APP_REALM_PUBLIC_KEY;
            if (publicKey.indexOf('-----BEGIN PUBLIC KEY-----') === -1) {
                publicKey = "-----BEGIN PUBLIC KEY-----" + publicKey + "-----END PUBLIC KEY-----";
            }
            return KJUR.jws.JWS.verifyJWT(rawBearerToken, publicKey, { alg: ['RS256'], verifyAt: parsedToken.iat });
        }
        catch (e) {
            return false;
        }
    };
    Security.resolveClientId = function (token, useTokenToLogin) {
        if (useTokenToLogin) {
            return token ? token.azp : '';
        }
        else {
            return process.env.VUE_APP_CLIENT_ID || '';
        }
    };
    Security.setUpdateTokenInterval = function () {
        var _this = this;
        if (Security.updateTokenInterval) {
            clearInterval(Security.updateTokenInterval);
            Security.updateTokenInterval = null;
        }
        Security.updateTokenInterval = setInterval(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                new Promise(function (resolve, reject) {
                    if (Security.keycloak) {
                        Security.keycloak.updateToken(70).success(function (refreshed) {
                            Security.authenticated(Security.keycloak.token);
                            resolve(refreshed);
                        });
                    }
                    else {
                        reject(false);
                    }
                }).then(function (refreshed) {
                    if (refreshed) {
                        Security.authenticated(Security.keycloak.token);
                        if (Security.onTokenUpdate && Security.keycloak.token) {
                            Security.onTokenUpdate(Security.keycloak.token);
                        }
                    }
                }).catch(function () {
                    console.error('failed to refresh token');
                    Security.notAuthenticated();
                    clearInterval(Security.updateTokenInterval);
                    Security.updateTokenInterval = null;
                });
                return [2 /*return*/];
            });
        }); }, 60000);
    };
    Security.initializeAuth = function (config, onLoad, redirectUrl) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var Keycloak;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.resolve().then(function () { return tslib_1.__importStar(require('keycloak-js')); })];
                    case 1:
                        Keycloak = _a.sent();
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                Security.keycloak = Keycloak.default(config);
                                var initOptions = {
                                    onLoad: onLoad,
                                };
                                if (redirectUrl) {
                                    Object.assign(initOptions, {
                                        redirectUri: redirectUrl,
                                    });
                                }
                                Security.keycloak.init(initOptions)
                                    .success(function (authenticated) {
                                    if (authenticated) {
                                        Security.authenticated(Security.keycloak.token);
                                        Security.setUpdateTokenInterval();
                                    }
                                    else {
                                        Security.notAuthenticated();
                                    }
                                    resolve({
                                        keycloak: Security.keycloak,
                                        authenticated: authenticated,
                                    });
                                })
                                    .error(function () {
                                    Security.notAuthenticated();
                                    reject(false);
                                });
                            })];
                }
            });
        });
    };
    Security.authenticated = function (token) {
        if (token === void 0) { token = ''; }
        Security.isLoggedIn = true;
        api_1.default.token = token;
    };
    Security.notAuthenticated = function () {
        Security.isLoggedIn = false;
    };
    Security.isLoggedIn = false;
    return Security;
}());
exports.default = Security;
//# sourceMappingURL=Security.js.map