"use strict";
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var vue_1 = tslib_1.__importDefault(require("vue"));
var vuex_1 = tslib_1.__importDefault(require("vuex"));
var api_1 = tslib_1.__importDefault(require("./api"));
var SecretType_1 = require("./models/SecretType");
var Snack_1 = require("./models/Snack");
vue_1.default.use(vuex_1.default);
exports.default = new vuex_1.default.Store({
    state: {
        hasMasterPin: false,
        userId: '',
        auth: {},
        config: {},
        tokens: {},
        wallets: [],
        chain: '',
        thirdPartytoken: {},
        loading: false,
        snack: {},
        hasBlockingError: false,
        showModal: false,
        transactionWallet: {},
    },
    mutations: {
        setProfile: function (state, _a) {
            var userId = _a.userId, hasMasterPin = _a.hasMasterPin;
            state.userId = userId;
            state.hasMasterPin = hasMasterPin;
        },
        setAuth: function (state, auth) {
            state.auth = auth;
        },
        setHasMasterPin: function (state, hasMasterPin) {
            state.hasMasterPin = hasMasterPin;
        },
        setWallets: function (state, wallets) {
            state.wallets = wallets;
        },
        addWallet: function (state, wallet) {
            state.wallets = state.wallets.concat([wallet]);
        },
        setChain: function (state, chain) {
            state.chain = chain;
        },
        setThirdPartyToken: function (state, thirdPartytoken) {
            state.thirdPartytoken = thirdPartytoken;
        },
        setLoading: function (state, isLoading) {
            state.loading = isLoading;
        },
        setSnack: function (state, snack) {
            state.snack = snack;
        },
        setHasBlockingError: function (state, hasBlockingError) {
            state.hasBlockingError = hasBlockingError;
        },
        setShowModal: function (state, showModal) {
            state.showModal = showModal;
        },
        setTransactionWallet: function (state, wallet) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                state.transactionWallet = wallet;
                return [2 /*return*/];
            });
        }); },
    },
    actions: {
        fetchUserData: function (store) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, api_1.default.getProfile().then(function (profile) {
                        store.commit('setProfile', profile);
                        return profile;
                    })];
            });
        }); },
        fetchUserWallets: function (store) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, api_1.default.getWallets().then(function (wallets) {
                        store.commit('setWallets', wallets);
                        return wallets;
                    })];
            });
        }); },
        updateMasterPin: function (store, _a) {
            var oldMasterPin = _a.oldMasterPin, masterPin = _a.masterPin;
            return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var success;
                return tslib_1.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, api_1.default.setMasterPin(masterPin, oldMasterPin)];
                        case 1:
                            success = _b.sent();
                            if (success) {
                                store.commit('setHasMasterPin', true);
                            }
                            return [2 /*return*/, success];
                    }
                });
            });
        },
        setMasterPin: function (store, masterPin) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var success;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, api_1.default.setMasterPin(masterPin)];
                    case 1:
                        success = _a.sent();
                        store.commit('setHasMasterPin', success);
                        return [2 /*return*/, success];
                }
            });
        }); },
        createWallet: function (store, _a) {
            var secretType = _a.secretType, pincode = _a.pincode, clients = _a.clients;
            return tslib_1.__awaiter(_this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_b) {
                    return [2 /*return*/, api_1.default.createWallet({ pincode: pincode, secretType: secretType, clients: clients })
                            .then(function (response) {
                            return new Promise(function (resolve, reject) {
                                if (response.success) {
                                    store.commit('addWallet', response.result);
                                    resolve(response.result);
                                }
                                else {
                                    reject(response.errors);
                                }
                            });
                        })];
                });
            });
        },
        startLoading: function (store) {
            store.commit('setLoading', true);
        },
        stopLoading: function (store) {
            store.commit('setLoading', false);
        },
        setError: function (store, message) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                store.commit('setSnack', { type: Snack_1.SnackType.DANGER, message: message, blocking: false });
                return [2 /*return*/];
            });
        }); },
        setBlockingError: function (store, message) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                store.commit('setHasBlockingError', true);
                store.commit('setShowModal', true);
                store.commit('setSnack', { type: Snack_1.SnackType.DANGER, message: message, blocking: true });
                return [2 /*return*/];
            });
        }); },
        resetError: function (store) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                store.commit('setSnack', {});
                return [2 /*return*/];
            });
        }); },
        showModal: function (store) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                store.commit('setShowModal', true);
                return [2 /*return*/];
            });
        }); },
        hideModal: function (store) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                store.commit('setShowModal', false);
                return [2 /*return*/];
            });
        }); },
        setTransactionWallet: function (store, wallet) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                store.commit('setTransactionWallet', wallet);
                return [2 /*return*/];
            });
        }); },
    },
    getters: {
        secretType: function (state) {
            return SecretType_1.SecretTypeUtil.byChain(state.chain);
        },
        thirdPartyClientId: function (state) {
            return state.thirdPartytoken.azp;
        },
    },
});
//# sourceMappingURL=store.js.map